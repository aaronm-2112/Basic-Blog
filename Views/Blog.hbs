<!-- Template for blog posts a user can create -->
<!-- TODO: Style everything better -->

<body>
  <header>
    <img src="{{titleImagePath}}" alt="Title Image">
    <h1>{{title}}</h1>
    <h2>{{username}}</h2>
  </header>

  <div id="content">
    {{content}}
  </div>

  <button id="comment">See Comments</button>

  <div id="comments-section">
    <div id="create-top-level-comment">
      <textarea name="user-top-level-comment-content" id="user-top-level-comment-content" cols="30" rows="10">Enter Your Comment Here
      </textarea>
      <button id="post-comment">Post</button>
    </div>
  </div>
</body>

<footer>
  <p>Footer stuff</p>
</footer>



<script>
  //blogid global
  var blogid;

  //gets the blogid fromthe url
  const getBlogid = () => {
    let url = document.URL;
    url = url.slice(0, url.lastIndexOf('/')); ///blog/id
    blogid = url.slice(url.lastIndexOf('/') + 1); //id
    console.log(blogid);
  }

  //execute getBlogid when window loads
  window.onload = getBlogid;

  //Loads all comments and replies -- happens when user clicks next or previous on the top level comment buttons
  async function loadAllComments() {
    try {
      //retrieve the blog's top level comments, if they exist
      let response = await fetch(`http://localhost:3000/comments?blog=${blogid}&reply=false&replyto=0&orderby=likes&likes=1000&commentid=1000`, {
        method: 'GET', headers: { 'Content-Type': 'application/json' }
      });

      //grab the comment data out of the response and store them in a top level comment collection
      let topLevelComments = [];
      topLevelComments = await response.json();
      console.log(topLevelComments);

      let bid = blogid.toString();
      let cid = 0;


      //create a key value collection of the comments' replies
      let topLevelCommentReplies = {};
      //traverse the top level comments collection
      for (let i = 0; i < topLevelComments.length; i++) {
        cid = topLevelComments[i].commentid.toString();
        //-----use the commentid of the current top level comment to fetch that comment's replies ordered by date
        let res =
          await fetch(`http://localhost:3000/comments?blog=${blogid}&reply=true&replyto=${cid}&orderby=date&likes=0&commentid=0`, {
            method: 'GET', headers: { 'Content-Type': 'application/json' }
          });
        //-----grab the replies out of the server response and load them into the key value reply collection
        let commentReplies = await res.json();
        //-----create a comment and return the HTML reply section created for it --this houses all replies to the comment
        let replySection = displayComment(topLevelComments[i]);
        //-----traverse through the replies for that top level comment
        for (let j = 0; j < commentReplies.length; j++) {
          displayReply(commentReplies[i], replySection);
        }
      }

    } catch (e) {
      console.log(e);
    }
  }

  //paginate through the replies for a particular top level comment
  //TODO: Add code to make grabbing the first and last reply safe
  async function paginateReplies(topLevelCommentid, flip) {
    //get the reply section we want to paginate to new replies within
    let topLevelCommentSection = document.getElementById(topLevelCommentid);
    let topLevelSectionChildren = topLevelCommentSection.children;
    let replySection = topLevelSectionChildren[3];

    let replyid = "";

    //check if flip value is next
    if (flip === 'next') {
      //if so get the last reply's commentid  by traversing to the last element in the reply section
      for (let i = 0; i < replySection.length; i++) { //pagination-div
        if (i == replySeciton.length - 1 && replySection[i].id != "pagination-div") {
          replyid = replySection[i].id;
          replyid = replyid.slice(replyid.lastIndexOf('-') + 1);
          console.log(replyid);
        }
      }
    } else { //user wants the previous pages results
      //------get the first reply's commentid
      //check if at pagination div and if any replies exist after it
      if (replySection.class == "pagination-div" && i < replySection.length - 1) {
        replyid = replySection[i + 1].id;
        replyid = replyid.slice(replyid.lastIndexOf('-') + 1);
        console.log(replyid);
      }
    }

    //clear the current replies in that reply section

    //fetch the next/previous 10 replies

    //place those replies into the reply section

    //determine which pagination buttons to hide/unhide
  }

  //Creates a new top level comment(not a reply) in the blog's comment section
  //TODO: Finish
  async function createTopLevelComment() {
    try {
      //grab the user's top level comment content 
      let content = document.getElementById('user-top-level-comment-content').value;
      console.log(content);
      //set the reply value
      let reply = false;

      //set the replyto value
      let replyto = 0;

      //send the comment data to the server
      let res = await fetch(`http://localhost:3000/comments`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ content, reply, replyto, blogid }) });

      //check if successful comment creation
      if (res.status !== 201) {
        return;
      }

      //retrieve commentid
      let cid = await res.json();

      //retrieve the comment the user created

      //display the user's comment at the botom of the comment section
      displayComment({});

      console.log(cid);
    } catch (e) {
      console.log(e);
    }
  }


  //create an HTML element that displays a comment onto the screen
  function displayComment(comment) {
    //create a div with class top level comment
    let div = document.createElement('div');
    div.setAttribute("class", 'top-level-comment');
    //set a unique id that matches with the add reply button
    div.setAttribute('id', `${comment.commentid}`);
    div.setAttribute("style", "border: 1px solid");

    //create a pragraph for the username of the comment
    let uname = document.createElement('p');
    uname.textContent = comment.username;

    //create a paragraph for the date of the comment
    let date = document.createElement('p');
    date.textContent = comment.created;

    //create a paragraph for the content of the comment
    let content = document.createElement('p');
    content.textContent = comment.content;

    //create a reply section for the comment
    let replySection = document.createElement('div');
    replySection.setAttribute('class', 'reply-section');
    replySection.setAttribute("style", "position: relative; left: 30px;");

    //create a reply textarea
    let replyTextArea = document.createElement('textarea');
    replyTextArea.setAttribute("class", "reply")
    replyTextArea.addEventListener("input", (e) => {
      replyTextArea.textContent = e.target.value;
    });

    //create a button that allows a user to add replies to the comment
    let btn = document.createElement('button');
    btn.textContent = "Reply";
    btn.setAttribute('id', `add-reply-${comment.commentid}`);


    //place the elements inside the comment div
    div.appendChild(uname);
    div.appendChild(date);
    div.appendChild(content);
    div.appendChild(replySection);

    //add the reply box to the reply section
    replySection.appendChild(replyTextArea);
    replySection.appendChild(btn);

    //create the buttons that allow users to paginate through the replies
    let paginationDiv = document.createElement('div');
    paginationDiv.setAttribute("class", "pagination-div");

    let btnNext = document.createElement('button');
    //set the ids using the unique top level comment id --will be used to identify which replies to get next when the click event bubbles up
    btnNext.setAttribute('id', `$btn-replies-next-${comment.commentid}`);
    btnNext.value = "Next";
    btnNext.textContent = "Next";
    let btnPrev = document.createElement('button');
    btnPrev.setAttribute('id', `$btn-replies-prev-${comment.commentid}`);
    btnPrev.value = "Previous";
    btnPrev.textContent = "Previous";

    //add the buttons to the pagination div
    paginationDiv.appendChild(btnPrev);
    paginationDiv.appendChild(btnNext);

    //append the btns into the replySection
    replySection.appendChild(paginationDiv);

    //append the div into the comments section
    let commentSection = document.getElementById('comments-section');

    commentSection.appendChild(div);

    //return the reply section
    return replySection;
  }


  //display the reply given comment data and a replysection
  //TODO: Test when adding a new reply!
  function displayReply(comment = {}, replySection = {}) {
    //----------create an html object 
    let div = document.createElement('div');
    div.setAttribute("class", 'reply-section-comment');
    div.setAttribute('style', "border: solid 1px; ");
    div.setAttribute('id', `reply-section-comment-${comment.commentid}`);
    //----------fill the html object wtih the reply values 
    let date = document.createElement('p');
    date.textContent = comment.created;
    let username = document.createElement('p');
    username.textContent = comment.username;
    let content = document.createElement('p');
    content.textContent = comment.content;
    //----------place the html object as a child of its top level comment's reply section
    div.appendChild(date);
    div.appendChild(username);
    div.appendChild(content);

    //append the reply to the replysection
    replySection.appendChild(div);
  }

  //event so that the users can create comments  
  document.getElementById('post-comment').addEventListener('click', createTopLevelComment);

  //activate the click for gathering all comments and displaying them on the screen
  document.getElementById('comment').addEventListener("click", loadAllComments);

  //event delegation that catches when a user creates a comment reply, wants to cycle through replies, or top level comments
  document.addEventListener('click', async function (e) {
    try {
      if (e.target && e.target.id.includes('add-reply')) { //user wants to create reply
        //identify which comment the reply belongs to 
        let commentid = e.target.id.slice(e.target.id.lastIndexOf('-') + 1); //because replies ids are: add-reply-commentid and comment section ids are: id: commentid

        //grab the top-level-comment html element with the same commentid -- this is where the reply is nested
        let topLevelCommentSection = document.getElementById(commentid);

        //extract the reply section html element from the top level comment section
        let topLevelSectionChildren = topLevelCommentSection.children;

        let replySection = topLevelSectionChildren[3];

        //add the reply to the database
        let reply = true;
        let replyto = commentid;
        let content = replySection.firstChild.value;
        let res = await fetch('http://localhost:3000/comments', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ content, reply, replyto, blogid }) });

        //get the repliy's cid
        let cid = await res.json();

        //fetch the new reply data and display it at the bottom of the reply section it belongs to
        res = await fetch(`http://localhost:3000/comments/${cid}`, { method: 'GET', headers: { 'Content-Type': 'application/json' } });

        //extract the comment from the json response
        let userReply = await res.json();
        console.log(userReply);

        //display the comment at the bottom of the reply section
        displayReply(userReply, replySection);
      } else if (e.target && e.target.id.includes('btn-replies')) {
        console.log("Here");
        //identify which top level comment the replies to paginate through belong to
        let commentid = e.target.id.slice(e.target.id.lastIndexOf('-') + 1);
        console.log(commentid);
        paginateReplies(commentid, "next");
      }
    } catch (err) {
      console.log(err);
    }
  });


</script>